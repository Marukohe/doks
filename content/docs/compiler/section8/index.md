---
title: "8 - 代码生成"
description: ""
lead: ""
date: 2021-04-09T18:23:24+08:00
lastmod: 2021-04-09T18:23:24+08:00
draft: false
images: []
menu: 
  docs:
    parent: "compiler"
weight: 7
toc: true
---

## 代码生成器的位置
+ 根据中间表示(IR)生成代码
+ 代码生成器之前可能有一个优化组件
+ 代码生成器的三个任务
  + 指令选择：选择适当的指令实现IR语句
  + 寄存器分配和指派：把哪个值放在哪个寄存器中
{{< img src="8-1.png" alt="Rectangle" class="border-0" >}}

## 要解决的问题
+ 正确性：正确的机器指令
+ 易于实现、测试和维护
+ 输入IR的选择
  + 四元式、三元式、字节代码、堆栈机器码、后缀表示、抽象语法树、DAG图
+ 输出
  + RISC、CISC
  + 可重定向代码、汇编语言

## 目标机模型
+ 使用三地址机器的模型
+ 指令
  + 加载：LD dst, addr（把地址addr中的内容加载到dst所指的寄存器）
  + 保存：ST x, r（把寄存器r中的内存保存到x中）
  + 计算：OP dst, src1, src2（把src1和src2中的值运算后将结果存放到dst中）
  + 无条件跳转：BR L（控制流转向标号L的指令）
  + 条件跳转：Bcond r, L（对r中的值进行测试，如果为真则转向L）

## 寻址模式
+ 变量$x$：指向分配$x$的内存位置
+ $a(r)$：地址是$a$的左值加上寄存器$r$中的值
+ constant($r$)：寄存器$r$中内存加上前面的常数即其地址
+ $*r$：寄存器$r$的内容所表示的位置上存放的内容位置
+ *constant($r$)：寄存器$r$中内容加上常量所代表的位置上的内容所表示的位置
+ 常量#constant

## 程序及指令的代价
+ 不同的目的有不同的度量
  + 最短编译时间、运行时间、目标程序大小、能耗
+ 不可判定一个目标程序是否最优
+ 假设每个指令有固定的代价，设定为1加上运算分量寻址模式的代价
  + LD R0, R1：代价为1
  + LR R0, M：代价为2
  + LR R1, *100(R2)：代价为2

## 目标代码中的地址
+ 如何为过程调用和返回生成代码
  + 静态分配
  + 栈式分配
+ 如何将IR中的名字（过程名或变量名）转换成为目标代码中的地址
  + 不同区域中的名字采用不同的寻址方式

## 活动记录的静态分配
+ 每个过程静态地址分配一个数据区域，其开始位置用staticArea表示
+ call calle的实现
  + ST callee.statisArea
  + BR callee.codeArea
+ callee中的语句return
  + BR *callee.staticArea
