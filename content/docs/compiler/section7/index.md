---
title: "7 - 运行时刻环境"
description: ""
lead: ""
date: 2021-04-09T18:23:21+08:00
lastmod: 2021-04-09T18:23:21+08:00
draft: false
images: []
menu: 
  docs:
    parent: "compiler"
weight: 6
toc: true
---

## 运行时刻环境
+ 运行时刻环境
  + 为数据分配安排存储位置
  + 确定访问变量时使用的机制
  + 过程之间的连接、参数传递
+ 主题
  + 存储管理：栈分配、堆管理、垃圾回收
  + 对变量、数据的访问

## 存储分配的典型方式
+ 目标程序的代码放置在代码区
+ 静态区、堆区、栈区分别放置不同类型生命期的数据值
  {{< img src="7-1.png" alt="Rectangle" class="border-0" >}}

## 静态和动态存储分配
+ 静态分配:
  + 编译器在编译时刻就可以做出存储分配决定，不需要考虑程序运行时刻的情形
  + 全局变量、全局常量
+ 动态分配
  + 栈式存储：和过程的调用/返回同步进行分配和回收，值得生命期域过程生命期相同
  + 堆存储：数据对象比创建它得过程调用更长寿
    + 手工进行回收
    + 辣鸡回收机制

## 栈式分配
+ 内容
  + 活动树
  + 活动记录
  + 调用代码序列
  + 栈中的变长数据

## 活动树
+ 过程调用（过程活动）在时间上总是嵌套的
  + 后调用的先返回
  + 因此用栈来分配过程活动所需内存空间
+ 程序运行的所有过程活动可以用树表示
  + 每个结点对应于一个过程活动
  + 根结点对应于main过程的活动
  + 过程$p$的某次活动对应的结点的所有子结点
    + 表示此次活动所调用的各个过程活动
    + 从左向右，表示调用的先后顺序

## 活动记录
+ 过程调用和返回由控制栈进行管理
+ 每个活跃的活动对应于栈中的一个活动记录
+ 活动记录按照活动的开始时间，从栈底到栈顶排列
  {{< img src="7-2.png" alt="Rectangle" class="border-0" >}}

## 调用代码序列
+ 调用代码序列为活动记录分配空间，填写记录中的信息
+ 返回代码序列恢复机器状态，使调用者继续运行
+ 调用代码序列会分割调用者和被调用者中
  + 根据源语言、目标机器和操作系统的限制，可以有不同的分割方案
  + 把代码尽可能放在被调用者中
  
## 调用/返回代码序列的要求
+ 数据方面
  + 能够把参数正确地传递给被调用者
  + 能够把返回值传递给调用者
+ 控制方面
  + 能够正确转到被调用过程的代码开始位置
  + 能够正确转回调用者的调用位置（的下一条指令）
+ 调用代码序列与活动记录的布局相关

## 活动记录的布局原则
+ 调用者和被调用者之间传递的值放在被调用者活动记录的开始位置
+ 固定长度的项（控制链、访问链和机器状态字段）放在中间位置
+ 早期不知道大小的项在活动记录尾部
+ 栈顶指针（top_sp）通常指向固定长度字段的末端
  {{< img src="7-3.png" alt="Rectangle" class="border-0" >}}

## 栈中的变长数据
+ 如果数据对象的生命期局限于过程活动的生命期，就可以分配在运行时刻栈中
  + 变长数组也可以
+ top指向实际栈顶
+ top_sp用于寻找顶层记录的定长字段
  {{< img src="7-4.png" alt="Rectangle" class="border-0" >}}

## 非局部数据的访问（无嵌套过程）
+ 没有嵌套过程时的数据访问
  + C语言中，每个函数都能访问的变量
    + 函数的局部变量：相对地址已知，且存放在当前活动记录内，top_sp指针加上相对地址即可访问
    + 全局变量：在静态区，地址在编译时刻可知
  + 很容易将C语言的函数作为参数进行传递
    + 参数中只需包括函数代码的开始地址
    + 在函数中访问非局部变量的模式很简单，不需要考虑过程如何激活的

## 非局部数据的访问（有嵌套过程）
+ PASCAL中，如果过程A的声明中包含了过程B的声明，那么B可以使用在A中声明的变量
+ 当B的代码运行时，如果它使用的是A中的变量，必须通过访问链访问
  {{< img src="7-5.png" alt="Rectangle" class="border-0" >}}

## 嵌套深度
+ 嵌套深度可根据源程序静态确定
  + 不内嵌于任何其它过程的过程,深度为1
  + 嵌套与深度为$i$的过程的过程,深度为$i+1$

## 访问链和访问链的使用
+ 访问链被用于访问非局部的数据
  + 如果过程$p$在声明时(直接)嵌套在过程$q$中，那么$p$活动记录中的访问链指向上层最近的$q$的活动记录
  + 从栈顶活动记录开始，访问链形成了一个链路，嵌套深度沿着链路逐一递减
+ 设深度为$n_p$的过程$p$访问变量$x$，而变量$x$在深度为$n_q$的过程$q$中声明
  + $n_p-n_q$在编译时刻已知；从当前活动记录除法，沿访问链前进$n_p-n_q$次找到活动记录
  + x相对于这个活动记录的偏移量在编译时可已知

## 访问链的维护
+ 当过程q调用过程p时
  + p的深度大于q：根据作用域规则,p必然在q中直接定义;那么p的访问链指向当前活动记录(即q)
  + 递归调用p=q：新活动记录的访问链等于当前记录的访问链(即和前一个q指向同一目标)
  + p的深度小于等于q的深度：必然有过程r,p直接在r中定义,而q嵌套在r中;p的访问链指向栈中r的活动记录

## 访问链的维护(过程指针型参数)
+ 在传递过程指针参数时,过程型参数中不仅包含过程的代码指针(开始地址),还包括正确的访问链

## 显示表
+ 用访问链访问数据，访问开销和嵌套深度差有关
  + 使用显示表可以提高效率，访问开销为常量
+ 显示表：数组$d$为每个嵌套深度保留一个指针
  + 指针$d[i]$指向栈中最近的、嵌套深度为$i$的活动记录
  + 如果过程$p$访问嵌套深度为$i$的过程$q$中声明的变量$x$，那么$d[i]$直接指向相应的活动记录($i$在编译时刻已知)
+ 显示表的维护
  + 调用过程$p$时，在$p$的活动记录中保存$d[n_p]$的值，并将$d[n_p]$设置为当前活动记录（即$p$）
  + 从$p$返回时，恢复$d[n_p]$的值

## 堆管理
+ 堆空间
  + 用于存放生命周期不确定、或生存到被明确删除为止的数据对象
  + 例如：new生成的对象可以生存到被delete为止，malloc申请的空间生存到被free为止
+ 存储管理器
  + 分配/回收堆区空间的子系统
  + 根据语言而定
    + C、C++需要手动回收空间
    + Java可以自动回收空间（垃圾回收）

## 存储管理器
+ 基本功能
  + 分配：为内存请求分配一段连续、适当大小的堆空间
    + 首先从空闲的堆空间分配
    + 如果不行则从操作系统中获取内存、增加堆空间
  + 回收：把被回收的空间返回空闲空间缓冲池，以满足其它内存需求
+ 评价存储管理器的特性
  + 空间效率：使程序需要的对空间最小，即减小碎片
  + 程序效率：运用内存系统的层次，使程序运行更快
  + 低开销：使分配/收回内存的操作尽可能高效

## 计算机的存储层次结构
{{< img src="7-6.png" alt="Rectangle" class="border-0" >}}

## 程序中的局部性
+ 程序具有高度的局部性
  + 时间局部性：一个程序访问的存储位置很可能将在一个很短的时间段内被再次访问
  + 空间局部性：被访问过的存储位置的临近位置很可能在一个很短的时间段内被访问
+ 90%的时间用来执行10%的代码
+ 局部性这一特性恰好可以充分利用计算机的层次存储结构

## 堆空间的碎片问题
+ 随着程序分配/回收内存，堆区逐渐被割裂成为若干空闲存储块（窗口）和已用存储块的交错
+ 分配一块内存时，通常是把一个窗口的一部分分配出去，其余部分成为更小的块
+ 回收时，被释放的存储块被放回缓存池；通常要把连续的窗口接合成为更大的窗口

## 堆空间分配方法
+ Best-fit
  + 总是将请求的内存分配在满足请求的最小的窗口中
  + 好处：可以将大的窗口保留下来，应对更大的请求
+ First-fit
  + 总是将对象防止在第一个能够容纳请求的窗口中
  + 放置对象时花费时间较少，但是总体性能较差
  + 通常具有较好的数据局部性：同一时间段内生成的对象经常被分配在连续的空间内

## 使用容器的堆管理方法
+ 舍顶不同大小的块规格，相同的块放入同一容器
+ 较小的（较常用的）尺寸设置较多的容器
+ 如GNU的C编译器将所有存储块对齐到8字节边界

## 管理和接合空闲空间
+ 当回收一个块时，可以把这个块和相邻的块接合起来，构成更大的块
  + 有些管理方法不需要进行接合
+ 支持相邻块接合的数据结构
  + 边界标记：在每个存储块的两端，分别设置一个free/used位，并在相邻的位置上存放字节总数
  + 双重链接的空闲块列表：列表的指针存放在空闲块中、用双向指针的方式记录了有哪些空闲块

## 处理手工存储管理
+ 两大问题：
  + 内存泄露：未能删除不可能再被引用的数据
  + 悬空指针引用：引用已被删除的数据
+ 其他问题：
  + 空指针访问/数据越界访问

## 垃圾回收
+ 垃圾
  + 广义：不需要再被引用的数据
  + 侠义：不能被引用（不可达）的数据
+ 垃圾回收：自动回收不可达数据的机制，解除了程序员的负担
  + 使用的语言：Java, Perl, ML, Modula-3, Prolog, Smalltalk

## 垃圾回收器的设计目标
+ 基本要求
  + 语言必须是类型安全的：保证回收器能够知道数据元素是否为一个指针某内存块的指针
  + 类型不安全的语言：C/C++
+ 性能目标
  + 总体运行时间：不显著增加应用程序的总运行时间
  + 空间使用：最大限度地利用可用内存
  + 停顿时间：当垃圾回收机制启动时，可能引用应用程序的停顿，这个停顿应该比较短
  + 程序局部性：改善空间局部性和时间局部性

## 可达性
+ 可达性就是指一个存储块可以被程序访问到
+ 根集：不需要指针解引用就可以直接访问的数据
  + Java：静态成员、栈中变量
+ 可达性
  + 根集的成员都是可达的
  + 对于任意一个对象，如果指向它的一个指针被保存在可达对象的某字段或数组元素中，那么这个对象也是可达的
+ 性质
  + 一旦一个对象变得不可达，它就不会再变成可达的

## 改变可达对象集合的操作
+ 对象分配
  + 返回一个指向新存储块的引用
+ 参数传递/返回值
  + 对象引用从实参传递到形参，从返回值传递给调用者
+ 引用赋值：$u=v$
  + $v$的引用被复制到$u$中，$u$中原有引用丢失；使$u$原来指向的对象变得不可达，并递归使更多对象变得不可达
+ 过程返回
  + 活动记录出栈，局部变量消失，根基变小，使一些对象变得不可达

## 垃圾回收方法
+ 关注不可达
  + 跟踪相关操作，捕获对象变得不可达的时刻，回收对象占用的空间
+ 关注可达
  + 在需要时，标记出所有可达对象，回收其它对象

## 基于引用计数的垃圾回收器
+ 每个对象有一个用于存放引用计数的字段，并按如下方式维护
  + 对象分配：引用计数设为1
  + 参数传递：引用计数加1
  + 引用赋值：$u=v$，$u$指向的对象引用减1，$v$指向的对象引用加1
  + 过程返回：局部变量指向对象的引用计数减1
+ 如果一个对象的引用计数为0，在删除对象之前，此对象中各个指针所指对象的引用计数减1
+ 开销加大，但不会引起停顿

## 基于跟踪的垃圾回收
+ 标记-清扫式垃圾回收
+ 标记并压缩垃圾回收
+ 拷贝垃圾回收

## 标记-清扫式垃圾回收
+ 一种直接的、全面停顿的算法
+ 分为两个阶段
  + 标记：从根基开始，跟踪并标记出所有可达对象
  + 清扫：遍历整个堆区，释放不可达对象
+ 如果把数据对象看作顶点，引用看作有向边，那么标记的过程实际上是从根基开始的图遍历过程

## 回收算法
{{< img src="7-7.png" alt="Rectangle" class="border-0" >}}

## 基本抽象分类
+ 每个存储块处于四种状态之一
  + 空闲、未被访问、待扫描、已扫描
+ 对存储块的操作会改变存储块的状态
  + 应用程序分配
  + 垃圾回收器扫描
  + 回收

## 标记并压缩垃圾回收
+ 对可达对象进行重定位可以消除存储碎片
  + 把可达对象移动到堆区的一端，另一端则是空闲空间
  + 空闲空间合并成单一块，提高分配内存时的效率
+ 整个过程分为三个步骤
  + 标记
  + 计算新位置
  + 移动并设置新的引用

## 拷贝垃圾回收
+ 堆空间被分为两个半空间
  + 应用程序在某个半空间内分配存储，当充满这个半空间时， 开始垃圾回收
  + 回收时，可达对象被拷贝到另一个版空间
  + 回收完成后，两个版空间角色对调
+ 优点
  + 不涉及任何不可达对象
