---
title: "3 - 词法分析"
description: ""
lead: ""
date: 2021-04-09T17:26:16+08:00
lastmod: 2021-04-09T17:26:16+08:00
draft: false
images: []
menu: 
  docs:
    parent: "compiler"
weight: 2
toc: true
---

## 词法分析器的作用

+ 读入字符流，组成词素，输出**词法单元**序列
+ 过滤空白、换行、制表符、注释等
+ 将词素添加到符号表中
+ 在逻辑上独立于语法分析，但是通常和语法分析处于同一趟中

### 为什么要设立独立的词法分析器？

+ 简化编译器的设计
  + 词法分析器可以首先完成一些简单的处理工作
+ 提高编译器效率
  + 相对于语法分析，词法分析过程简单，可高效实现（下推自动机vs.有穷自动机）
+ 增强编译器的可移植性

### 词法单元、模式、词素

+ 词法单元（Token）
  + <词法单元名、属性值（可选）>
  + 单元名时表示词法单位种类的抽象符号，语法分析器通过单元名即可确定词法单元序列的结构
  + 属性值通常用于语义分析之后的阶段
+ 模式（Pattern）
  + 描述了一类词法单元的词素可能具有的形式
+ 词素（Lexeme）
  + 源程序中的字符序列
  + 它和某个词法单元的模式匹配，被词法分析器识别为该词法单元的实例
+ 一些例子
  {{< img src="3-1.png" alt="Rectangle" class="border-0" >}}

### 词法单元的属性

+ 一个模式匹配多个词素时，必须通过**属性**来传递附加的信息
  + 属性值将被用于语义分析、代码生成等阶段
+ 不同的目的需要不同的属性
  + 属性值通常是一个结构化数据
+ 如词法单元id的属性
  + 词素、类型、第一次出现的位置...

## 词法单元的规约（正则表达式）

+ **正则表达式**可以高效、简洁地描述处理词法单元时用到的模式类型

### 串和语言（1）

+ **字母表**：一个有穷的符号集合
  + 符号典型例子：字母、数字、标点符号
  + 在理论上，我们可以把任意的有限集合看作字母表
+ 字母表上的**串**是该表中符号的**有穷序列**
  + 串$s$的长度，即|s|，是指$s$中符号出现的次数
  + 空串：长度为0的串，$\epsilon$
+ **语言**是某个给定字母上的串的**可数**集合

### 串和语言（2）

+ 和串有关的术语
  + 前缀：从串的尾部删除0个或多个符号后得到的串
  + 后缀：从串的开始处删除0个或多个符号后得到的串
  + 子串：删除串的某个前缀和某个后缀得到的串
  + 真前缀、真后缀、真子串：既不等于原串，也不等于空串的前缀、后缀、子串

### 串和语言（3）

+ 串的运算
  + 连接（Concatenation）：$x$和$y$的连接是把$y$附加到$x$的后面而形成的串，记作$xy$
  + 指数运算（幂运算）：$s^0=\epsilon, s^1=s, s^i=s^{i-1}s$

### 串和语言（4）

+ 语言的运算
  + 语言是某个给定字母表上的串的可数**集合**
  {{< img src="3-2.png" alt="Rectangle" class="border-0" >}}

## 词法单元的规约（正则表达式）

+ 字母表$\Sigma$上的正则表达式的定义
  + 基本部分
    + $\epsilon$是一个正则表达式，$L(\epsilon)=\\{\epsilon\\}$
    + 如果$a$是$\Sigma$上的一个符号，那么$a$是正则表达式，$L(a)=\\{a\\}$
  + 归纳步骤
    + 选择：$(r)|(s), L((r)|(s))=L(r)\cup L(s)$
    + 连接：$(r)(s), L((r)(s))=L(r)L(s)$
    + 闭包：$(r)^\*, L((r)^\*)=(L(r))^\*$
    + 括号：$(r), L((r))=L(r)$
+ 运算的有限集：$^*$ > 连接 > |，如$(a)\|((b)^\*(c)))=a|b^\*c$
+ 正则集合：可以用一个正则表达式定义的语言

### 正则定义

+ 先定义再使用
+ 不能重复定义
+ 为了书写方便，可以给正则表达式命名，且可以通过名字使用正则表达式
+ 正则定义是如下形式的定义序列
  + $d_1\rightarrow r1$
+ 其中
  + $d_i$不在$\Sigma$中，且各不相同
  + 每个$r_i$是字母表$\Sigma\cup \\{d_1,d_2,...,d_{i-1}\\}$上的正则表达式；这保证了不会出现递归定义

### 正则表达式的扩展

+ 基本运算符：选择、连接、Kleene闭包
+ 扩展的运算符
  + 一个或多个实例：单目后缀$^+$
    + $r^+$等价于$rr^*$
  + 零个或一个实例：$?$
    + $r?$等价于$\epsilon\mid r$
  + 字符类
    + $[a_1a_2...a_n]$等价于$a_1\mid a_2\mid ...\mid a_n$
    + $[a-e]$等价于$a\mid b\mid c\mid d\mid e$

## 词法单元的识别（状态转换图）

+ 词法分析器要求能够检查输入字符串，在其前缀中找出和某个模式匹配的词素
+ 首先通过正则定义来描述各种词法单元的模式
+ 定义$ws\rightarrow(blank\mid tab\mid newline)^+$来消除空白
  + 当词法分析器识别出这个模式时，不返回词法单元，继续识别其它模式
+ Eg.
  + $digit\rightarrow[0-9]$
  + $digits\rightarrow digit^+$
  + $number\rightarrow digits(.digits)?(E[+-]?digits)?$
  + $letter\rightarrow[A-Za-z]$
  + $id\rightarrow letter(letter\mid digit)^*$
  + $if\rightarrow$ if
  + $then\rightarrow$ then
  + $else\rightarrow$ else
  + $relop\rightarrow <\mid >\mid <=\mid >=\mid =\mid<>$

### 状态转换图

+ 词法分析器的重要组件之一
+ **状态转换图**
  + **状态**：表示在识别词素时可能出现的情况
    + 状态看作是已处理部分的总结
    + 某些状态为**接受状态**或**最终状态**，表明已找到词素
    + 加上$^*$的接受状态表示最后读入符号不在词素内
    + **开始状态（初始状态）**：用Start表示
  + **边**：从一个状态指向另一个状态
    + 边的标号是一个或多个符号
    + 当前为$s$，下一个输入符号为$a$，就沿着从$s$离开，标号为$a$的边到达下一个状态

### 保留字和标识符的识别

+ 在很多时候，保留字也符合标识符的模式
  + 识别标识符的状态转换图也会识别保留字
+ 解决办法
  + 在符号表中 **先填保留字**，并指明它们不是普通标识符
  + 为保留字建立独立的、**高优先级** 的状态转换图

### 词法分析器的体系结构

+ 从转换图构造词法分析器的方法
  + 变量State记录当前状态
  + 一个switch根据State的值转到相应的代码
  + 每个状态对应于一段代码
    + 这段代码根据读入的符号，确定下一个状态
    + 如果找不到相应的边，则调用`fail()`进行错误恢复
  + 进入某个接受状态时，返回相应的词法单元
    + 注意状态有$^*$标记时，需要回退forward指针

## 词法分析器生成工具及设计

### 词法分析器工具Lex/Flex

+ Lex/Flex是一个有用的词法分析器生成工具
+ 通常和YACC/Bison一起使用，生成编译器的前端
+ 使用过程图
  {{< img src="3-3.png" alt="Rectangle" class="border-0" >}}

### Lex源程序的结构

+ 声明部分
  + 常量：表示常数的标识符
  + 正则定义
+ 转换规则
  + 模式{动作}
    + 模式是正则表达式
    + 动作表示识别到相应模式时应采取的处理方式
    + 处理方式通常用C语言代码表示
+ 辅助函数
  + 各个动作中使用的函数
+ 一个例子
  {{< img src="3-4.png" alt="Rectangle" class="border-0" >}}

### Lex中的冲突解决办法

+ 冲突：多个输入前缀与某个模式相匹配，或者一个前缀与多个模式匹配
+ Lex解决冲突的方法
  + 多个前缀可能匹配时，选择 **最长的** 前缀
+ 某个前缀和多个模式匹配时，选择列在 **前面的** 模式

## 有穷自动机

### 有穷自动机

+ 本质上和状态转换图相同，但有穷自动机只回答Yes/No
  + 分为两类
    + 不确定的有穷自动机（NFA）：边上的标号没有限制，一个符号可出现在离开同一个状态的多条边上，$\epsilon$可以做标号
    + 确定的有穷自动机（DFA）：对于每个状态以及每个符号，有且只有一条边（或最多只有一条边）
+ 两种自动机都识别正则语言

### 不确定的有穷自动机（NFA）

+ NFA的定义
  + 一个有穷的状态集合$S$
  + 一个输入符号集合$\Sigma$
  + 转换函数对于每个状态和$\Sigma\cup\\{\epsilon\\}$中的符号，给出相应的后继状态`集合`
  + $S$中的某个状态$s_0$被指定为开始状态/初始状态
  + $S$的一个子集$F$被指定为接受状态集合

### 转换表表示法

+ 用二维表表示NFA的转换函数
  + 每行对应于一个状态
  + 每列对应于一个输入符号或者$\epsilon$
  + 每个条目表示对应的后继状态集合
+ 一个例子
  {{< img src="3-5.png" alt="Rectangle" class="border-0" >}}

### 输入字符串的接受

+ 一个NFA接受输入字符串$x$
  + 当且仅当对应的状态转换图中存在一条从开始状态到某个接受状态的路径，且该路径上的标号按顺序组成$x$（不含$\epsilon$标号）
+ NFA接受的语言：从开始状态到达接受状态的所有路径的标号串的集合

### 确定的有穷自动机（DFA）

+ 一个NFA被称为DFA，如果
  + 没有标号为$\epsilon$的转换，并且
  + 对于每个状态$s$和每个输入符号$a$，有且仅有一条标号为$a$的离开$s$的边

### 从正则表达式到自动机的转换

+ 正则表达式转化为DFA的步骤：
  + 正则表达式到NFA
  + NFA到DFA

### NFA到DFA（子集构造法）（1）

+ 基本思想
  + 构造得到的DFA的每个状态和NFA的状态子集对应
  + DFA读入$a_1,a_2,...,a_n$后到达的状态对应于从NFA开始状态除法沿着$a_1,a_1,...,a_n$可能到达的状态集合
  + 在算法中“并行地模拟”NFA在遇到一个给定输入串时可能执行的所有动作

### NFA到DFA（子集构造法）（2）

+ 理论上，最坏情况下DFA的状态个数会是NFA状态个数的指数多个

### NFA到DNA（子集构造法）（3）

+ 算法中使用的基本操作
  + $\epsilon-closure(s)$：从NFA状态$s$开始，只通过$\epsilon$转换能到达的NFA状态集合
  + $\epsilon-closure(T)$：从$T$中某个状态$s$开始，只通过$\epsilon$转换能到达的NFA状态集合
  + $move(T,a)$：从$T$中某个状态$s$出发，通过一个标号$a$的转换能到达的NFA状态集合

### NFA到DFA（子集构造法）（4）

+ 计算$\epsilon-closure(T)$的算法
  {{< img src="3-6.png" alt="Rectangle" class="border-0" >}}

### NFA到DFA（子集构造法）（5）

+ 整个算法实际上是一个搜索的过程
  + $Dstates$中的一个状态未加标记表示还没有搜索过它的各个后继
  {{< img src="3-7.png" alt="Rectangle" class="border-0" >}}

### 正则表达式到NFA

+ 基本思想
  + 根据正则表达式的地规定定义，按照正则表达式的结构递归地构造相应的NFA
  + 算法分为两个部分：
    + 基本规则处理$\epsilon$和单符号的情况
    + 对于每个正则表达式的运算，建立组合相应NFA的方法

### NFA合并的方法

+ 合并方法：
  + 引入新的开始状态，并引入从该开始状态到各个原开始状态的$\epsilon$转换
  + 得到的NFA所接受的语言是原来各个NFA语言的并集
  + 不同的接收状态代表不同的模式

### 确定化NFA后的处理

+ 对得到的NFA进行确定化，得到DFA
+ 一个DFA的接受状态对应于NFA的状态子集，其中至少包括一个NFA的接收状态
  + 如果其中包括多个对应于不同模式的NFA接收状态，则表示当前输出前缀对应于多个模式，存在冲突。

### DFA状态数量的最小化

+ 一个正则语言可对应于多个识别此语言的DFA
+ 通过DFA的最小化可得到状态数量最少的DFA（不计同构，这样的DFA是唯一的）

### 状态的区分

+ 状态的**可区分**：
  + 如果存在串$x$，是的从状态$s_1$和$s_2$，一个到达接收状态而另一个到达非接收状态，那么$x$就区分了$s_1$和$s_2$
  + 如果存在某个串区分了$s$和$t$，我们说$s$和$t$是可区分的，否则它们是不可区分的
+ 不可区分的两个状态就是**等价**的，可以合并

### DFA最小化算法

+ 把所有可区分的状态分开（迭代过程）
  + 基本步骤：$\epsilon$区分了接受状态和非接受状态
  + 归纳步骤：如果$s$和$t$是可区分的，且$s'$到$s$，$t'$到$t$有标号为$a$的边，那么$s'$和$t'$也是可区分的
+ 最终没有区分开的状态就是等价的
  + 所有的死状态都是等价的
+ 从划分得到的等价类中选区代表，并重建DFA

### 最小化算法（划分部分）

{{< img src="3-8.png" alt="Rectangle" class="border-0" >}}

### 最小化算法（构造部分）

{{< img src="3-9.png" alt="Rectangle" class="border-0" >}}

### 词法分析器状态的最小化

+ 基本思想和DFA最小化算法相同
+ 差别：
  + 词法分析器中的接受状态对应于不同的模式
  + 对应不同模式的接受状态一定是不等价的
  + 初始化分为：所有非接收状态集合+对应**各模式**的接收状态集合
+ 其余划分和构造的方法均相同
+ 接受状态对应的模式就是原来的模式
