---
title: "第三章 运输层"
description: ""
lead: ""
date: 2021-04-09T23:10:15+08:00
lastmod: 2021-04-09T23:10:15+08:00
draft: false
images: []
menu: 
  docs:
    parent: "computer-network"
weight: 9
toc: true
---

## 3.1 概述和运输层服务
+ 运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能
+ 运输层协议是在端系统中而不是在路由器中实现的
  
### 3.1.1 运输层和网络层的关系
+ 运输层协议只工作在端系统中。在端系统中，运输层协议将来自应用进程的报文移动到网络边缘（网络层）
+ 运输层能够提供的服务常常受制于底层网络层协议的服务模型
  
### 3.1.2 因特网运输层服务
+ 因特网两种运输层协议：
  - UDP：不可靠的、无连接的服务
  - TCP：可靠的、面向连接的服务
+ UDP和TCP的最基本的责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程间的交付服务。将主机交付扩展到进程间被称为**运输层的多路复用**与**多路分解**。
+ 进程到进程的数据交付和差错检测是两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务。

## 3.2 多路复用与多路分解
+ 将运输层报文段中的数据交付到正确的套接字的工作称为**多路分解**
+ 在源主机从不同套接字中手机数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为**多路复用**
+ 运输层多路复用要求:
  1. 套接字有唯一标识符；
  2. 每个报文段有特殊字段来指示该报文段所要交付到的套接字，这些特殊的字段是源端口号字段和目的端口号字段。
  3. 端口号是一个16比特的数，范围在0 $\sim$ 65535之间
  4. 0 $\sim$ 1023范围的端口号称为**周知端口号**，是受限制的，保留给诸如HTTP和FTP之类的周知应用层协议来使用
+ 运输层报文段中的源与目的端口字段
  {{< img src="TCP-UDP报文段格式.png" alt="Rectangle" caption="<em>TCP-UDP报文段格式</em>" class="border-0" >}}


### 1. 无连接的多路复用与多路分解
+ 一个UDP套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号

### 2. 面向连接的多路复用与多路分解
+ TCP套接字是由一个四元组（源IP地址，源端口号，目的IP地址，目的端口号）来标识的。

### 3. Web服务器与TCP
+ 当今的刚性能Web服务器通常只是用一个进程，但是为每个新的客户连接创建一i个具有新连接套接字的新线程。

## 3.3 无连接运输：UDP
+ 使用UDP时，在发送报文段之前，发送方和接收方的运输层实体之间没有握手。正因为如此，UDP被称为是无连接的。
+ 适合使用UDP的场景：
  - 关于发送什么数据以及何时发送的应用层控制更为精细
  - 无须连接建立。TCP具有连接时延
  - 无连接状态。TCP需要在端系统中维护连接状态。
  - 分组首部开销小。TCP报文段有20字节的首部开销，而UDP仅有8字节的开销。
+ 有些应用能容忍少量的分组丢失，因此可靠数据传输对于这些应用的成功并不是至关重要的。此外，TCP的拥塞控制会导致如因特网电话、视频会议的实时应用性能变得很差。

### 3.3.1 UDP报文段结构
+ 因为数据字段的长度在一个UDP段中不同于在另一个段中，故需要一个明确的长度（首部加数据）。
  {{< img src="CN_3.3.1.jpg" alt="Rectangle" class="border-0" >}}

### 3.3.2 UDP校验和
+ 发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。
+ 在接收方，全部的4个16比特（包括校验和）加在一起。如果该分组中没有引入差错，则显然在接收方处该和将是11111111111111。如果这些比特之一是0，那么我们就知道该分组中已经出现了差错。

## 3.5 面向连接的运输TCP
### 3.5.1 TCP连接
+ TCP被称为是**面向连接的**，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。
+ TCP连接时**全双工服务**：如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可以从进程B流向进程A的同时，也从进程A流向进程B。
+ TCP连接总是**点对点**的，即在单个发送方与单个接收方之间的连接。
+ TCP将数据引导到该连接的发送缓存里，发送缓存时发起三次握手期间设置的缓存之一。
+ TCP可从缓存中取出并放入被吻短中的数据数量受限于**最大报文段长度**(MSS)。
+ MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（**最大传输单元**MTU）来设置
+ MSS指在报文段里应用层数据的最大长度，而不是指包括首部的TCP报文段的最大长度
+ TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段。

### 3.5.2 TCP报文段结构
+ TCP报文段结构
  {{< img src="CN_3.5.2.jpg" alt="Rectangle" class="border-0" >}}
+ TCP的首部一般是20字节
+ TCP报文段首部：
  - 源端口号和目的端口号
  - 32比特的序号字段和32比特的确认号字段
  - 16比特的接收窗口字段：用于流量控制
  - 4比特的首部长度字段
  - 可选与变长的选项字段：用于发送方与接收方协商最大报文长度时，或在高速网络环境下用作窗口调节因子时使用。
  - 6比特的标志字段

#### 1. 序号和确认号
+ 一个报文段的序号是该报文段首字节的字节流编号
+ 主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号
+ TCP只确认流中至第一个丢失字节为止的字节，所以TCP被称为提供累积确认。

#### 2. 序号和确认号的一个学习案例
+ 对客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段中，这种确认被认为是**捎带**在服务器到客户的数据报文段中。

### 3.5.3 往返时间的估计与超时
#### 1. 估计往返时间
+ 报文段的样本RTT就是从报文段被发出到对该报文段的确认被收到之间的时间量
+ 设置一个平均时间，称为指数加权移动平均，一个给定的SampleRTT的权值在更新过程中呈指数型快速衰减。
$$
EstimatedRTT = (1-\alpha)\cdot EstimatedRTT + \alpha\cdot SampleRTT
$$
+ RTT偏差
$$
DevRTT = (1-\beta)\cdot DevRTT + \beta\cdot |SampleRTT - EstimatedRTT|
$$
#### 2. 设置和管理重传超时间间隔
+ 确定重传超时间隔
$$
TimeoutInterval = EstimatedRTT + 4\cdot DevRTT
$$

### 3.5.4 可靠数据传输
+ TCP在IP不可靠的尽力而为服务之上创建了一种可靠数据传输服务

+ 发送端事件处理流程
  ```
  /*假设发送方不受TCP流量控制和拥塞控制，每一个数据小于MSS.*/
  NextSeqNum = InitialSeqNum
  SendBase = InitialSeqNum
  
  loop(永远){
    switch(event):
  
      case 从上层应用接收数据：
        生成序号为NextSeqNum的报文;
        if(定时器没有启动){
          启动定时器;
        }
        向IP传递报文;
        NextSeqNum += 数据字节数;
        break;
  
      case 超时：
        重传SendBase对应的TCP报文; /*和GBN不同之处*/
        TimeoutInterval *= 2;
        重启定时器; /*每次重传一个报文后都会重新启动定时器*/
        break;
  
      case 接收ACK, AN = y:
        if(y > SendBase){
          SendBase = y; /*采取累计确认*/
          重新计算TimeoutInterval;
          if(仍有发送且未确认报文){
            重启定时器;
          }
        }
        else{/*实际上此时y == SendBase*/
            y的冗余数量 += 1;
            if(y的冗余数量 == 3){
              /*快速重传*/
              立即重传序号为y对应的报文;
            }
        }
        break;
    }
  ```

+ 接收端产生ACK的情况在RFC 5681中建议：

  | 事件                                                         | 动作                                                         |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 具有**所期望序号**的按序报文段到达且在此**之前的报文段都已经被确认**，即本报文段是当前状态下第一个接收但未被确认的报文 | Delayed ACK，延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK。 |
  | 具有**所期望序号**的按需报文段到达且当前有一个报文段等待ACK传输，即此时处于事件一的状态 | 立马发送单个累计ACK，确认这两个报文                          |
  | 比**所期望序号大的失序**报文段到达，即接收产生了间隔         | 立即发送冗余ACK，指示下一个期待字节的序号（其为间隔的低端的序号） |
  | 能部分或完全填充接收数据间隔的报文段到达                     | 如果该报文段序号起始于间隔的低端，则立即发送ACK              |
  {.table-striped}

#### 1. 一些有趣的情况
1. 主机A发送的报文在主机B上收到，但从主机B发往主机A的确认报文丢失了。超时事件发生，主机A会重传相同的报文段。
2. 主机A发送了两个报文段，都被主机B接收，但是在超时之前B发送的两个确认报文没有一个到达A。A重传第一个报文，在超时间隔内B发送的第二个确认到达了A。第二个报文段不会被重传。
3. 同2，但是在超时之前，A收到了第二个确认报文，第一个确认报文丢失，A不会重传任何报文。

#### 2. 超时间隔加倍
+ 超时间隔在每次重传后加倍，呈指数型增长。每当定时器在另两个事件（即收到上层应用的数据和收到ACK）中的任意一个启动时，TimeoutInterval由最近的EstimatedRTT值与DevRTT值推算得到。

#### 3. 快速重传
+ 当发送方收到3个冗余ACK时，不用管定时器是否过期，立即重传丢失的报文段。

#### 4. 是回退N步还是选择重传
+ 选择确认：它允许TCP接收方有选择地确认失序报文段，而不是累计地确认最后一个正确接收的有序报文段。

### 3.5.5 流量控制
+ TCP为它的应用程序提供了**流量控制服务**，以消除发送方使接收方缓存溢出的可能性。
+ TCP通过让发送方维护一个称为**接收窗口**的变量来提供流量控制。
+ $RcvBuffer$：主机B维护的接收缓存大小，主机B上的进程不时地从该缓存中读取数据
  - $LastByteRead$：主机B上的应用进程从缓存中读出的数据流的最后一个字节的编号。
  - $LastByteRcvd$：从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号。
  - 由于TCP不允许已分配的缓存溢出，下式必须成立：
    $$
    LastByteRcvd-LastByteRead\leq RcvBuffer
    $$
    接收窗口用$rwnd$表示，根据缓存可用空间的数量来设置：
    $$
    rwnd = RcvBuffer-[LastByteRcvd-LastByteRead]
    $$
+ 主机B通过把当前的$rwnd$值放入它发给主机A的报文段接收窗口字段中，通知主机A它在该链接的缓存中还有多少可用空间。初始值$rwnd = RcvBuffer$
+ 主机A轮流跟踪两个变量，$LastByteSent$和$LastByteAcked$。主机A需要保证未确认的数据量在$rwnd$内
  $$
  LastByteSent-LastByteAcked\leq rwnd
  $$
+ TCP规范中要求，当主机B的接收窗口为0时，主机A继续发送一个只有一个字节数据的报文段。这些报文段将会被接受方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的$rwnd$值。

### 3.5.6 TCP 连接管理
+ 三次握手
  {{< img src="三次握手.png" alt="Rectangle" class="border-0" >}}


+ 关闭连接：通过FIN包关闭
  {{< img src="关闭连接.png" alt="Rectangle" class="border-0" >}}

+ 客户TCP经历的典型的TCP状态序列
  {{< img src="客户TCP状态" alt="Rectangle" class="border-0" >}}

+ 服务器端TCP端经历的典型的TCP状态序列
  {{< img src="服务器TCP状态.png" alt="Rectangle" class="border-0" >}}

+ 如果一台主机收到一个TCP报文段，其端口号和源IP地址与该主机上进行中的套接字都不匹配。则该主机向源发送一个特殊重置报文段，该TCP报文段将RST置为1。当一台主机接收一个UDP分组，它的目的端口与进行中的UDP套接字不匹配，该主机发送一个特殊的ICMP数据报。

  nmap通过这种方法进行端口扫描。如果收到SYNACK，说明目的主机的对应端口号打开；如果收到RST，说明目的主机端口号关闭且没有被防火墙阻拦；如果什么都没收到，说明报文段在传输过程中被防火墙阻拦。

## 3.6 拥塞控制原理

### 3.6.1 拥塞原因与代价

#### 1. 情况1：两个发送方和一台具有无穷大缓存的路由器
+ 来自主机A和主机B的分组通过一台路由器，以相同速率在一段容量为$R$的共享式输出链路上传输。当发送速率在$0\sim R/2$之间时，接收方的吞吐量等于发送方的发送速率。但是由于共享链路容量有限，无论主机A和主机B将其发送速率设置为多高，它们都不会看到超多$R/2$的吞吐量。
+ 从吞吐量角度看，运行在总吞吐量接近$R$的状态也许是一个理想状态，但从时延角度看，却远不是一个理想状态。
+ **甚至在这种（极端）理想化的情况中，我们已经发现了网络拥塞的一种代价，即当分组的到达速率接近链路容量时，分组经历巨大的排队时延。**
+ 拥塞情况1
  {{< img src="拥塞情况1.png" alt="Rectangle" class="border-0" >}}

#### 情况2：两个发送方和一台具有有限缓存的路由器
+ $\lambda_{in}^\prime$：网络的**供给荷载**，
+ 具有有限缓存时拥塞情况2
  {{< img src="拥塞情况2.png" alt="Rectangle" class="border-0" >}}
+ **我们在此看到了另一种网络拥塞的代价，即发送方必须执行重传以补偿因为缓存溢出而丢弃（丢失）的分组**（如上图b)
+ **网络拥塞的另一种代价，即发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本**（如上图c）

#### 情况3：4个发送方和具有有限缓存的多台路由器及多跳路径

+ **由于拥塞而丢弃分组的另一种代价，即当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而只用的传输容量最终被浪费了。**

### 3.6.2 拥塞控制方法

+ 端到端拥塞控制：在端到端拥塞控制方法中，网络层没有为运输层拥塞控制提供显示支持。即使网络中存在拥塞，端系统也必须通过对网络行为的观察来推断之。TCP采用端到端的方法解决拥塞控制，因为IP层不会向端系统提供有关网络拥塞的反馈信息。
+ 网络辅助的拥塞控制：在网络辅助的拥塞控制中，路由器向发送方提供关于网络中拥塞状态的显示反馈信息。
  - 直接反馈信息：可以由网络路由器发给发送方。这种方式的通知通常采用了一种**拥塞分组**的形式。
  - 经由接收方的网络反馈：路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生。一旦收到一个标记的分组后，接收方就会向发送方通知该网络拥塞指示。

## 3.7 TCP拥塞控制

+ 运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即**拥塞窗口**。拥塞窗口表示为$cwnd$，它对一个TCP发送方能向网络中发送流量的速率进行了限制。即
  $$
  LastByteSent-LastByteAcked\leq \min{cwnd,rwnd}
  $$
+ 发送方的发送速率是$cwnd/RTT$字节/秒。通过调节$cwnd$的值，发送方能调整它向连接发送数据的速率。
+ 因为TCP只用确认来触发增大它的拥塞窗口长度，TCP被说成是自计时的。
+ TCP使用了下列指导性原则：
  - 一个丢失的报文意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率。
  - 一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。
  - 带宽探测。
+ **TCP拥塞控制算法**：1. 慢启动；2. 拥塞避免；3. 快速恢复。慢启动和拥塞避免是TCP的强制部分，快速恢复是推荐部分。
+ TCP拥塞控制算法的FSM描述
  {{< img src="拥塞控制算法.png" alt="Rectangle" class="border-0" >}}

### 1. 慢启动

+ 在慢启动状态，$cwnd$值以1个$MSS$开始并且每当传输报文段首次被确认就增加1个$MSS$。每过一个$RTT$，发送速率就翻番。
+ 慢启动的结束：
  1. 存在一个由超时指示的丢包时间（即拥塞），TCP发送方将$cwnd$设置为1并重新开始慢启动过程。它还将第二个状态变量的值$ssthresh$（”慢启动阈值“）设置为$cwnd/2$，即当检测到拥塞时将$ssthresh$设置为拥塞窗口值的一半。
  2. 当$cwnd$的值等于$ssthresh$时，结束慢启动并且TCP转移到拥塞避免模式。
  3. 如果检测到3个冗余ACK，这时TCP执行一种快速重传并进入快速恢复状态。

### 2. 拥塞避免

+ 每个$RTT$只将$cwnd$增加一个$MSS$。
+ 当出现超时时，$cwnd$的值被设置为1个$MSS$，当丢包事件出现时，$ssthresh$的值被更新为$cwnd$值的一半。
+ 如果丢包事件由3个冗余ACK触发，$cwnd$设置为更新后的$ssthresh$值+3。接下来进入快速恢复状态。

### 3. 快速恢复

+ 在快速恢复中，对引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK，$cwnd$的值增加一个$MSS$。最终，当对丢失报文段的一个ACK到达时，TCP在降低$cwnd$后进入拥塞避免状态。
+ 如果出现超时事件，快速恢复在执行如同慢启动和拥塞避免中相同的动作后，迁移到慢启动状态。

### 4. TCP拥塞控制：回顾

+ TCP Vegas算法：
  1. 在分组丢失发生之前，在源与目的地之间检测路由器中的拥塞。
  2. 当检测出快要发生的分组丢失时，线性地降低发送速率。快要发生的分组丢失是通过观察$RTT$来预测的。分组的$RTT$越长，路由器中的拥塞越严重。

### 5. 对吞吐量的宏观描述

$$
一条连接的平均吞吐量=\frac{0.75\times W}{RTT}
$$

### 6. 经高带宽路径的TCP

+ L：丢包率

$$
一条连接的平均吞吐量=\frac{1.22\times MSS}{RTT\sqrt{L}}
$$

### 3.7.1 公平性

+ 理想状态下，在瓶颈链路上传输的多条TCP连接会收敛于公平享有链路带宽的状态
  {{< img src="公平性.png" alt="Rectangle" class="border-0" >}}

+ 但实际上，那些具有较小$RTT$的连接能够在链路空闲时更快地抢到可用带宽（即较快地打开拥塞窗口），因而将比那些具有较大$RTT$地连接想用更高地吞吐量。

#### 1. 公平性和UDP

+ 由于UDP连接没有拥塞控制，可能会压制TCP流量。

#### 2. 公平性和并行TCP连接

+ 如今许多Web浏览器使用多个并行TCP连接来传送一个Web页中的多个对象，抢占了链路传输中的带宽。

### 3.7.2 明确拥塞通告：网络辅助拥塞控制
+ 对于IP和TCP的扩展方案已经提出并已经实现和部署，该方案允许网络明确向TCP发送方和接收方发出拥塞信号。这种形式的网络辅助拥塞控制称为**明确拥塞通告**（ECN）。
+ 在网络层中，IP数据报首部的服务类型字段中的两个比特被用于ECN。
+ 路由器所使用的一种ECN比特设置指示该路由器正在历经拥塞。
+ 发送主机使用的另一种ECN比特设置通知路由器发送方和接收方是ECN使能的，能够对于ECN指示的网络拥塞采取行动。
+ 当接受主机中的TCP通过一个接收到的数据报收到了一个ECN拥塞指示时，接收主机中的TCP通过在接收方到发送方的TCP ACK报文段中设置ECE（明确拥塞通告回显）比特，通知发送主机中的TCP收到拥塞指示。接下来，TCP发送方通过减半拥塞窗口对一个具有ECE拥塞指示的ACK做出反映，并在下一个传输的TCP发送方到接收方的报文段首部中对CWR（拥塞窗口缩减）比特进行设置。
+ 流程图
  {{< img src="明确拥塞通告.png" alt="Rectangle" class="border-0" >}}
